#include "../constants.h"
#include "random.h"
#include "math.h"
#include "../engine/battle/core.h"

void Random(void){
    //  A simple hardware-based random number generator (RNG).

//  Two random numbers are generated by adding and subtracting
//  the divider to the respective values every time it's called.

//  The divider is a register that increments at a rate of 16384Hz.
//  For comparison, the Game Boy operates at a clock speed of 4.2MHz.

//  Additionally, an equivalent function is executed in VBlank.

//  This leaves a with the value in hRandomSub.

    PUSH_BC;

    LDH_A_addr(rDIV);
    LD_B_A;
    LDH_A_addr(hRandomAdd);
    ADC_A_B;
    LDH_addr_A(hRandomAdd);

    LDH_A_addr(rDIV);
    LD_B_A;
    LDH_A_addr(hRandomSub);
    SBC_A_B;
    LDH_addr_A(hRandomSub);

    POP_BC;
    RET;

}

//  A simple hardware-based random number generator (RNG).
//  Two random numbers are generated by adding and subtracting
//  the divider to the respective values every time it's called.
//  The divider is a register that increments at a rate of 16384Hz.
//  For comparison, the Game Boy operates at a clock speed of 4.2MHz.
//  Additionally, an equivalent function is executed in VBlank.
//  This leaves a with the value in hRandomSub.
uint8_t Random_Conv(void) {
    uint8_t f = REG_F;

    uint16_t temp;
    temp = (gb_read(rDIV) + hram->hRandomAdd + REG_F_C);
    advance_div(128);
    REG_F_C = (temp & 0xFF00)? 1 : 0;
    hram->hRandomAdd = (uint8_t)temp;

    temp = (gb_read(rDIV) - hram->hRandomSub - REG_F_C);
    REG_F_C = (temp & 0xFF00)? 1 : 0;
    advance_div(128);
    hram->hRandomSub = (uint8_t)temp;

    REG_F = f;

    return (uint8_t)(temp & 0xff);
}

void BattleRandom(void){
    //  _BattleRandom lives in another bank.

//  It handles all RNG calls in the battle engine, allowing
//  link battles to remain in sync using a shared PRNG.

    LDH_A_addr(hROMBank);
    PUSH_AF;
    LD_A(BANK(av_BattleRandom));
    RST(aBankswitch);

    CALL(av_BattleRandom);

    LD_addr_A(wPredefHL + 1);
    POP_AF;
    RST(aBankswitch);
    LD_A_addr(wPredefHL + 1);
    RET;

}

//  _BattleRandom lives in another bank.
//  It handles all RNG calls in the battle engine, allowing
//  link battles to remain in sync using a shared PRNG.
uint8_t BattleRandom_Conv(void){
    // LDH_A_addr(hROMBank);
    // PUSH_AF;
    // LD_A(BANK(av_BattleRandom));
    // RST(aBankswitch);

    // CALL(av_BattleRandom);

    // LD_addr_A(wPredefHL + 1);
    // POP_AF;
    // RST(aBankswitch);
    // LD_A_addr(wPredefHL + 1);
    // RET;
    return v_BattleRandom_Conv();
}

void RandomRange(void){
    //  Return a random number between 0 and a (non-inclusive).

    PUSH_BC;
    LD_C_A;

// b = $100 % c
    XOR_A_A;
    SUB_A_C;

mod:
        SUB_A_C;
    IF_NC goto mod;
    ADD_A_C;
    LD_B_A;

// Get a random number
// from 0 to $ff - b.
    PUSH_BC;

loop:
        CALL(aRandom);
    LDH_A_addr(hRandomAdd);
    LD_C_A;
    ADD_A_B;
    IF_C goto loop;
    LD_A_C;
    POP_BC;

    CALL(aSimpleDivide);

    POP_BC;
    RET;

}

//  Return a random number between 0 and a (non-inclusive).
uint8_t RandomRange_Conv(uint8_t a){
    // b = $100 % c
    uint8_t b = (uint8_t)(0x100 % a);

// Get a random number
// from 0 to $ff - b.
    uint8_t value;
    do {
        Random_Conv();
        value = gb_read(hRandomAdd);
    } while(value > 0xFF - b);

    return SimpleDivide_Conv(value, a).rem;
}